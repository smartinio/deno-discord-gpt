import {
  ResponseInput,
  ResponseInputImage,
} from "https://jsr.io/@openai/openai/4.96.0/resources/responses/responses.ts";
import {
  ImagesResponse,
} from "https://jsr.io/@openai/openai/4.96.0/resources.ts";

import { AskAI } from "./ai.ts";
import { lock, redis } from "./redis.ts";
import { OpenAI } from "@openai/openai";
import { Log } from "./logger.ts";
import { resolveImageAsFile, saveGeneratedImage } from "./images.ts";
import { decodeBase64 } from "https://deno.land/std@0.224.0/encoding/base64.ts";

const OPENAI_API_KEY = Deno.env.get("OPENAI_API_KEY") as string;

const openAI = new OpenAI({
  apiKey: OPENAI_API_KEY,
  maxRetries: 3,
});

const getLastResponseId = async (channelId: bigint) => {
  return await redis.get<string>(`openai:last_response_id:${channelId}`);
};

const setLastResponseId = async (channelId: bigint, responseId: string) => {
  return await redis.set(`openai:last_response_id:${channelId}`, responseId);
};

const getLastImageUrl = async (channelId: bigint) => {
  return await redis.get<string>(`openai:last_image_url:${channelId}`);
};

const setLastImageUrl = async (channelId: bigint, imageUrl: string) => {
  return await redis.set(`openai:last_image_url:${channelId}`, imageUrl);
};

const systemPrompt =
  "You are an assistant in a Discord channel. Answer as concisely as possible, but match the tone and language of the person talking to you. Don't overdo it. Skip emojis and excessive slang. Never try to be on a moral high ground. Don't censor profanity. Never tell the person you're talking to to be open minded or similar if they happen to be stereotypical or prejudicing - it's OK for this conversation.";

const openai_images_generate = {
  type: "function",
  name: "openai_images_generate",
  description:
    "Generate an image with GPT Image 1. Use this when the user doesn't supply an image, or when the user isn't happy at all with the initial generation. If the user just wants a small tweak to an already generated image, prefer using the `openai_images_edit` function instead.",
  parameters: {
    type: "object",
    properties: {
      prompt: {
        type: "string",
      },
    },
    required: ["prompt"],
    additionalProperties: false,
  },
  strict: true,
} as const;

const openai_images_edit = {
  type: "function",
  name: "openai_images_edit",
  description:
    "Edit input image with GPT Image 1. Use this either when the user supplies a new image, or when the user wants small tweaks to the image previously generated by the model. If the user isn't happy at all with the initial generation, prefer using the `openai_images_generate` function instead.",
  parameters: {
    type: "object",
    properties: {
      prompt: {
        type: "string",
      },
    },
    required: ["prompt"],
    additionalProperties: false,
  },
  strict: true,
} as const;

const validateGenerateImageArguments = (
  data: unknown,
): data is { prompt: string } => {
  return data !== null && typeof data === "object" && "prompt" in data &&
    typeof data.prompt === "string";
};

const validateEditImageArguments = (
  data: unknown,
): data is { prompt: string } => {
  return data !== null && typeof data === "object" && "prompt" in data &&
    typeof data.prompt === "string";
};

const generateImage = async ({
  stringArgs,
  log,
  notify,
}: {
  stringArgs: string;
  log: Log;
  notify: (message: string) => void;
}): Promise<{ error: string } | { result: ImagesResponse }> => {
  const args = JSON.parse(stringArgs);

  if (!validateGenerateImageArguments(args)) {
    log.error("Invalid arguments from OpenAI", { args });

    return { error: "Sorry, couldn't generate your image. Please try again." };
  }

  const { prompt } = args;

  log.info("Generating image", { prompt });

  notify("Generating image. Might take a while...");

  return {
    result: await openAI.images.generate({
      prompt,
      model: "gpt-image-1",
      quality: "medium",
      n: 1,
    }),
  };
};

const editImage = async ({
  stringArgs,
  url,
  log,
  notify,
}: {
  stringArgs: string;
  url: string;
  log: Log;
  notify: (message: string) => void;
}): Promise<{ error: string } | { result: ImagesResponse }> => {
  const args = JSON.parse(stringArgs);

  if (!validateEditImageArguments(args)) {
    log.error("Invalid arguments from OpenAI", { args });

    return {
      error: "Sorry, couldn't edit your image. Please try again later.",
    };
  }

  const { prompt } = args;

  log.info("Editing image", { prompt, url });

  notify("Editing image. Might take a while...");

  return {
    result: await openAI.images.edit({
      prompt,
      model: "gpt-image-1",
      image: await resolveImageAsFile(url),
      quality: "medium",
      n: 1,
    }),
  };
};

const model = "o4-mini";

export const ask = async ({
  question,
  channelId,
  log,
  images = [],
  notify,
}: AskAI): Promise<string | { answer: string; imageUrl?: string }> => {
  return await lock(channelId, async () => {
    const lastResponseId = await getLastResponseId(channelId) || undefined;

    const input: ResponseInput = [];

    if (!lastResponseId) {
      input.push({
        role: "system",
        content: [{ type: "input_text", text: systemPrompt }],
      });
    }

    const inputImages = images.map(({ url }): ResponseInputImage => (
      {
        type: "input_image",
        image_url: url,
        detail: "low",
      }
    ));

    const inputImage = inputImages[0]?.image_url;

    // todo make less hacky
    if (inputImage) {
      await setLastImageUrl(channelId, inputImage);
    }

    input.push({
      role: "user",
      content: [
        { type: "input_text", text: question },
        ...inputImages,
      ],
    });

    const response = await openAI.responses.create({
      model,
      input,
      store: true,
      previous_response_id: lastResponseId,
      tool_choice: "auto",
      tools: [
        openai_images_generate,
        openai_images_edit,
      ],
    });

    if (response.error) {
      log.error("OpenAI error", { response });
      return "Sorry, something went wrong. Please try again.";
    }

    const functionCall = response.output.find((item) =>
      item.type === "function_call"
    );

    log.info("response output", { output: response.output });

    let image: {
      mime: string;
      url: string;
      blob: Blob;
    } | undefined;

    const handleImageResponse = async (
      imageResponse: { error: string } | { result: ImagesResponse },
    ) => {
      if ("error" in imageResponse) {
        return {
          answer: imageResponse.error,
        };
      }

      const b64 = imageResponse.result.data?.[0].b64_json;

      if (!b64) {
        log.error("Failed to generate image", {
          result: imageResponse.result,
        });

        return {
          answer: "Sorry, the image could not be generated. Please try again.",
        };
      }

      const { mime, url } = await saveGeneratedImage(b64);

      image = {
        mime,
        url,
        blob: new Blob([decodeBase64(b64)], { type: mime }),
      };

      await setLastImageUrl(channelId, image.url);
    };

    if (functionCall) {
      log.info("Function call", { functionCall });
    }

    switch (functionCall?.name) {
      case "openai_images_generate": {
        const imageResponse = await generateImage({
          stringArgs: functionCall.arguments,
          log,
          notify,
        });

        const done = await handleImageResponse(imageResponse);

        if (done) return done;

        break;
      }

      case "openai_images_edit": {
        const url = inputImages[0]?.image_url ||
          (await getLastImageUrl(channelId));

        if (!url) {
          return {
            answer: "Sorry, I can't edit your image. Please try again.",
          };
        }

        const imageResponse = await editImage({
          stringArgs: functionCall.arguments,
          url,
          log,
          notify,
        });

        const done = await handleImageResponse(imageResponse);

        if (done) return done;

        break;
      }
    }

    await setLastResponseId(channelId, response.id);

    if (!image || !functionCall) {
      return { answer: response.output_text };
    }

    const finalResponse = await openAI.responses.create({
      model,
      input: [
        {
          type: "function_call_output",
          call_id: functionCall.call_id,
          output: "<suppressed - output sent as attachment>",
        },
      ],
      store: true,
      previous_response_id: response.id,
      tool_choice: "auto",
      tools: [
        openai_images_generate,
        openai_images_edit,
      ],
    });

    await setLastResponseId(channelId, finalResponse.id);

    return {
      answer: finalResponse.output_text,
      image,
    };
  });
};
